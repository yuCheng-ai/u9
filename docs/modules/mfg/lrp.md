# LRP 批次需求计划 (LRP) - 开发者详尽指南

## 概述
LRP（Lot Requirements Planning）是 U9 的“杀手锏”。对于开发者来说，MRP 是“全局网状计算”，而 LRP 是**“线性链条计算”**。它的核心任务是建立并维护一条从销售订单到采购单的**硬连接（Hard Pegging）**。

---

## 1. 供需链条的“硬锁定”逻辑 (Hard Pegging)

### 企业痛点
**“明明是给 A 客户买的料，被 B 客户的订单领走了”**。

### 开发逻辑点
- **需求标识 (DemandID)**: 每一个 LRP 产生的建议单据都必须存储源单标识。
    - **PG 实现建议**: 利用 PostgreSQL 的 **`UUID`** 作为全局唯一的需求追踪 ID，并在所有关联表上建立索引。
- **库存隔离**: 
    - 开发者需在库存表设计 `ProjectID` 字段。
    - **PG 实现建议**: 启用 **行级安全 (RLS)**，让生产领料单只能“看见”属于其项目或 LRP 批次的库存，在数据库层级实现强硬锁定。
- **自动锁定**: 
    - 入库时自动过账到逻辑私有仓。
    - **PG 实现建议**: 使用 **触发器 (Triggers)** 在库存更新时自动填充 `LRP_Batch_ID`。

---

## 2. 齐套分析算法 (Kitting Analysis)

### 企业痛点
**“生产线开工了才发现少一个零件，全线停工”**。

### 开发逻辑点
- **模拟展开**: 递归展开 BOM。
    - **PG 实现建议**: 利用 PostgreSQL 的 **递归 CTE (Recursive CTE)** 实现毫秒级的全阶 BOM 需求展开。
- **匹配逻辑**: 
    - 专用库存 -> 专用在途 -> 缺口。
    - **PG 实现建议**: 使用 **窗口函数 (Window Functions)** 和 **`FILTER` 子句** 在单次扫描中完成“专用”与“通用”库存的优先级匹配计算。
- **计算最早开工日**: 
    - `MAX(到货日)`。
    - **PG 实现建议**: 使用 **自定义聚合函数** 或 **存储过程** 封装齐套性检查算法，减少前后端数据交互开销。

---

## 3. LRP 的局部计算引擎 (Local Engine)

### 企业痛点
“运行一次全局 MRP 要 2 小时，我只想算这一个急单”。

### 开发逻辑点
- **计算范围控制**: 
    - 以 `SourceOrderID` 为根节点。
    - **PG 实现建议**: 使用 **`UNLOGGED TABLE`** 存储 LRP 计算过程中的中间数据，大幅提升写入性能，计算完成后自动清理。
- **并发冲突**: 
    - 全局排队或快照预留。
    - **PG 实现建议**: 利用 PostgreSQL 的 **咨询锁 (Advisory Locks)** 实现对特定 LRP 任务的串行化控制，防止多个局部计算抢占同一批通用物料。

---

## 4. 批次合并与拆分逻辑 (Aggregation & Split)

### 企业痛点
“虽然是按单采购，但螺丝钉总不能一颗一颗买，供应商不卖”。

### 开发逻辑点
- **合并规则**: 
    - **PG 实现建议**: 利用 **`GROUP BY`** 结合 **`STRING_AGG`** 记录合并后的采购单关联的所有原始需求 ID，保持链路透明。
- **拆分溯源**: 
    - **PG 实现建议**: 利用 PostgreSQL 的 **JSONB** 存储合并明细，方便在到货入库时通过 SQL 函数快速拆分并更新各原始需求的满足状态。

---

## 5. 开发者 Checklist

- [ ] **高精度计算**: 齐套分析涉及的各级数量换算是否统一使用 **`numeric`**？
- [ ] **数据完整性**: 删除了源单后，是否通过 **触发器** 或 **逻辑复制** 级联更新了 LRP 链路状态？
- [ ] **跨组织协作**: 是否利用 **`postgres_fdw`** 实现跨组织库存和需求的实时可见与锁定？
- [ ] **性能优化**: 是否对 `DemandID` 和 `LRP_Batch_ID` 建立了高效的 B-Tree 索引？
