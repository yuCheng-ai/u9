# LRP 批次需求计划 (LRP) - 开发者详尽指南

## 概述
LRP（Lot Requirements Planning）是 U9 的“杀手锏”。对于开发者来说，MRP 是“全局网状计算”，而 LRP 是**“线性链条计算”**。它的核心任务是建立并维护一条从销售订单到采购单的**硬连接（Hard Pegging）**。

---

## 1. 供需链条的“硬锁定”逻辑 (Hard Pegging)

### 企业痛点
**“明明是给 A 客户买的料，被 B 客户的订单领走了”**。

### 开发逻辑点
- **需求标识 (DemandID)**: 每一个 LRP 产生的建议单据（生产订单、采购申请）都必须强制存储 `SourceOrderType` + `SourceOrderID` + `SourceLineID`。
- **库存隔离**: 
    - 开发者需在库存表设计 `ProjectID` 或 `TaskID` 字段。
    - 在领料校验接口中，必须实现：`IF (Material.ProjectID != MO.ProjectID) THEN 报错并拦截`。
- **自动锁定**: 入库时，系统需自动将物料过账到该订单名下的“逻辑私有仓”。

---

## 2. 齐套分析算法 (Kitting Analysis)

### 企业痛点
**“生产线开工了才发现少一个零件，全线停工”**。

### 开发逻辑点
- **模拟展开**: 开发者需根据订单 BOM 进行递归展开，获取全阶需求清单。
- **匹配逻辑**: 
    - 1. 优先匹配该订单已预留的“专用库存”。
    - 2. 其次匹配已下单但未到货的“专用在途”。
    - 3. 最后计算“缺口量”。
- **计算最早开工日 (Available-to-Promise)**: 
    - `开工日 = MAX(所有子件的预计到货日)`。
    - 这是一个典型的聚合计算，开发者需优化递归效率。

---

## 3. LRP 的局部计算引擎 (Local Engine)

### 企业痛点
“运行一次全局 MRP 要 2 小时，我只想算这一个急单”。

### 开发逻辑点
- **计算范围控制**: 
    - 开发者在设计 LRP 存储过程时，需以 `SourceOrderID` 作为根节点。
    - **隔离性**: 计算过程不应扫描非相关的需求记录，从而将计算耗时从“小时级”降低到“秒级”。
- **并发冲突**: 虽然是局部计算，但如果多个 LRP 同时抢占通用库存，开发者必须实现一个**全局排队机制**或**快照预留机制**。

---

## 4. 批次合并与拆分逻辑 (Aggregation & Split)

### 企业痛点
“虽然是按单采购，但螺丝钉总不能一颗一颗买，供应商不卖”。

### 开发逻辑点
- **合并规则**: 
    - 开发者需设计“合并池”。
    - 规则：`IF (Item.IsStandardPart == True) THEN 按周/按月合并 LRP 需求`。
- **拆分溯源**: 
    - 当一个合并后的采购单到货时，开发者必须实现“反向分摊算法”，将库存按比例自动分配回各个原始 LRP 订单。

---

## 5. 开发者 Checklist

- [ ] **链路完整性**: 删除了销售订单，是否级联清理了相关的 LRP 建议单？（或标记为孤儿单）。
- [ ] **性能**: 齐套分析是否使用了临时表或内存计算来加速多级 BOM 展开？
- [ ] **状态校验**: 只有“核准”状态的销售订单才能运行 LRP。
- [ ] **跨组织**: LRP 是否支持“A 组织销售，B 组织生产，C 组织采购”的跨组织链路锁定？
