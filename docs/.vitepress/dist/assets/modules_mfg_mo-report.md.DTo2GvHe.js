import{_ as a,c as s,o as e,ae as t}from"./chunks/framework.CDjunVez.js";const g=JSON.parse('{"title":"工序汇报与移动点管理 - 开发者详尽指南","description":"","frontmatter":{},"headers":[],"relativePath":"modules/mfg/mo-report.md","filePath":"modules/mfg/mo-report.md"}'),l={name:"modules/mfg/mo-report.md"};function o(r,i,n,h,d,c){return e(),s("div",null,[...i[0]||(i[0]=[t(`<h1 id="工序汇报与移动点管理-开发者详尽指南" tabindex="-1">工序汇报与移动点管理 - 开发者详尽指南 <a class="header-anchor" href="#工序汇报与移动点管理-开发者详尽指南" aria-label="Permalink to &quot;工序汇报与移动点管理 - 开发者详尽指南&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>工序汇报（Reporting）是 ERP 系统的“神经网络”。开发者必须理解：汇报不只是填个数字，它是<strong>物料流转、工序结转、成本分配、质量追溯</strong>的联合触发器。如果汇报逻辑不严密，生产进度就会失真，成本核算就会变成“乱账”。</p><hr><h2 id="_1-工序流转的逻辑约束-operation-move-logic" tabindex="-1">1. 工序流转的逻辑约束 (Operation Move Logic) <a class="header-anchor" href="#_1-工序流转的逻辑约束-operation-move-logic" aria-label="Permalink to &quot;1. 工序流转的逻辑约束 (Operation Move Logic)&quot;">​</a></h2><h3 id="企业痛点" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“第一道工序还没做完，第二道工序就报工了，数据全乱了”</strong>。</p><h3 id="开发逻辑点" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>前置工序校验</strong>: <ul><li>开发者需在报工 API 中实现逻辑：<code>IF (Op20.Report_Qty &gt; Op10.Passed_Qty) THEN REJECT_REPORT</code>。</li><li><strong>特例处理</strong>: 支持“并行工序”或“搭接工序”的特殊校验逻辑。</li></ul></li><li><strong>移动点模型 (Move Point)</strong>: <ul><li>每一个工序汇报应产生两条记录：<code>汇报（报数）</code> 和 <code>移动（传给下一站）</code>。</li><li>开发者需维护 <code>Operation_WIP_Balance</code> 表，实时记录每一道工序的“待加工”、“加工中”、“已完工待移走”状态。</li></ul></li></ul><h3 id="postgresql-实现建议" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>行级并发控制</strong>: 使用 <code>SELECT ... FOR UPDATE</code> 锁定特定工序的 <code>WIP_Balance</code> 记录，确保在高频报工环境下数量增减的绝对准确。</li><li><strong>递归状态追溯</strong>: 利用 <code>WITH RECURSIVE</code> 向上追溯所有前置工序的累计产出，确保当前工序报工数不超标。</li><li><strong>状态快照 (JSONB)</strong>: 在汇报记录中通过 <code>JSONB</code> 字段保存当时的工序状态快照，便于后期进行生产过程的“数字化回放”。</li></ul><hr><h2 id="_2-产出数量的精细化处理-yield-scrap" tabindex="-1">2. 产出数量的精细化处理 (Yield &amp; Scrap) <a class="header-anchor" href="#_2-产出数量的精细化处理-yield-scrap" aria-label="Permalink to &quot;2. 产出数量的精细化处理 (Yield &amp; Scrap)&quot;">​</a></h2><h3 id="企业痛点-1" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-1" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p>“报废了 10 个，但系统里还是按 100 个在算成本”。</p><h3 id="开发逻辑点-1" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-1" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>三量模型</strong>: 开发者必须强制采集三个维度： <ul><li><code>Qualified_Qty</code> (合格): 计入下一道工序的可用数。</li><li><code>Scrap_Qty</code> (报废): 触发原材料成本核销，不再向下流转。</li><li><code>Rework_Qty</code> (返修): 挂起该部分数量，直到返修合格。</li></ul></li><li><strong>自动补料申请</strong>: <ul><li>如果 <code>报废量 &gt; 预设损耗</code>，开发者需自动生成一条“补料申请建议”发给生产主管。</li></ul></li></ul><h3 id="postgresql-实现建议-1" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-1" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>约束校验 (CHECK)</strong>: 在数据库层增加约束，确保 <code>qualified_qty + scrap_qty + rework_qty &lt;= input_qty</code>，防止应用层逻辑漏洞导致的数据溢出。</li><li><strong>异步触发补料 (NOTIFY)</strong>: 当报废量触发阈值时，通过 <code>NOTIFY</code> 发送消息，由后台服务异步处理补料逻辑，避免阻塞报工主流程。</li><li><strong>物化视图汇总</strong>: 使用物化视图汇总各车间的报废率，为管理层提供实时质量预警。</li></ul><hr><h2 id="_3-工时采集与效率分析-time-tracking" tabindex="-1">3. 工时采集与效率分析 (Time Tracking) <a class="header-anchor" href="#_3-工时采集与效率分析-time-tracking" aria-label="Permalink to &quot;3. 工时采集与效率分析 (Time Tracking)&quot;">​</a></h2><h3 id="企业痛点-2" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-2" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“工人都说干了 8 小时，但产出只有 4 小时的量”</strong>。</p><h3 id="开发逻辑点-2" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-2" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>时间戳采集</strong>: <ul><li>开发者不应只提供“工时”录入框。</li><li>更好的设计是 <code>StartTime</code> 和 <code>EndTime</code>。接口需校验：<code>EndTime - StartTime</code> 是否等于录入的 <code>WorkHours</code>。</li></ul></li><li><strong>效率计算公式</strong>: <ul><li><code>效率 = (合格产出 * 标准工时) / 实际投入工时</code>。</li><li>开发者需实现一个异步计算引擎，每天凌晨汇总当天的“工序效率排行”。</li></ul></li></ul><h3 id="postgresql-实现建议-2" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-2" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>时间范围类型 (TSRANGE)</strong>: 使用 <code>tsrange</code> 存储工人的作业时间段，并利用 <code>EXCLUDE</code> 约束防止同一工人或机器在同一时间内重叠报工。<div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> labor_report </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EXCLUDE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">USING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gist (worker_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, work_period </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp;);</span></span></code></pre></div></li><li><strong>窗口函数分析</strong>:<div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker_id, </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">       SUM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UPPER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(work_period) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LOWER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(work_period)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">OVER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PARTITION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_time</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> labor_report;</span></span></code></pre></div></li><li><strong>自动聚合 (pg_cron)</strong>: 配置 <code>pg_cron</code> 定时任务，在低峰期自动执行效率分析聚合脚本。</li></ul><hr><h2 id="_4-完工入库的自动触发-auto-finish" tabindex="-1">4. 完工入库的自动触发 (Auto-Finish) <a class="header-anchor" href="#_4-完工入库的自动触发-auto-finish" aria-label="Permalink to &quot;4. 完工入库的自动触发 (Auto-Finish)&quot;">​</a></h2><h3 id="企业痛点-3" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-3" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p>“最后一道工序报工了，但成品库里还没看见货”。</p><h3 id="开发逻辑点-3" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-3" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>末道工序逻辑</strong>: <ul><li>开发者需在工序定义中增加 <code>Is_Final_Operation</code> 标志位。</li></ul></li><li><strong>自动入库</strong>: 当末道工序汇报审核时，开发者需自动调用 <code>Inventory_In_API</code> 生成“成品入库单”。</li><li><strong>事务保证</strong>: 汇报与入库必须在同一个数据库事务中，防止数据不一致。</li></ul><h3 id="postgresql-实现建议-3" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-3" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>存储过程封装</strong>: 将“末道报工 + 库存增加 + 状态更新”封装在一个 <code>PL/pgSQL</code> 函数中，确保事务的原子性。</li><li><strong>外键级联检查</strong>: 通过外键关联确保入库单必须引用有效的报工单记录。</li><li><strong>审计日志</strong>: 利用 PG 的 <code>INSERT INTO ... RETURNING</code> 语法，在完成自动入库后立即获取入库单号并反馈给前端。</li></ul><hr><h2 id="_5-开发者-checklist" tabindex="-1">5. 开发者 Checklist <a class="header-anchor" href="#_5-开发者-checklist" aria-label="Permalink to &quot;5. 开发者 Checklist&quot;">​</a></h2><ul><li>[ ] <strong>幂等性</strong>: 工人可能因为网络问题点击两次“汇报”，接口必须支持幂等（通过唯一 <code>RequestID</code> 校验）。</li><li>[ ] <strong>PDA 适配</strong>: 汇报接口是否支持高频、简化的扫描调用？</li><li>[ ] <strong>人员校验</strong>: 报工人员是否属于该 <code>WorkCenter</code>？</li><li>[ ] <strong>逆向操作</strong>: 报工撤销（Un-report）时，是否能级联撤销后续已生成的入库单和成本凭证？</li></ul>`,38)])])}const k=a(l,[["render",o]]);export{g as __pageData,k as default};
