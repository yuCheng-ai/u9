import{_ as o,c as a,o as i,ae as t}from"./chunks/framework.CDjunVez.js";const u=JSON.parse('{"title":"齐套分析与生产备料 - 开发者详尽指南","description":"","frontmatter":{},"headers":[],"relativePath":"modules/mfg/mo-prepare.md","filePath":"modules/mfg/mo-prepare.md"}'),r={name:"modules/mfg/mo-prepare.md"};function s(l,e,n,d,c,h){return i(),a("div",null,[...e[0]||(e[0]=[t('<h1 id="齐套分析与生产备料-开发者详尽指南" tabindex="-1">齐套分析与生产备料 - 开发者详尽指南 <a class="header-anchor" href="#齐套分析与生产备料-开发者详尽指南" aria-label="Permalink to &quot;齐套分析与生产备料 - 开发者详尽指南&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>备料（Preparation）是生产的“弹药补给”。开发者必须解决的核心问题是：<strong>如何在有限的资源下，实现最优的库存预留与发料逻辑</strong>。这不仅涉及库存扣减，更涉及复杂的优先级算法。</p><hr><h2 id="_1-齐套分析算法-优先级抢占-kitting-logic" tabindex="-1">1. 齐套分析算法：优先级抢占 (Kitting Logic) <a class="header-anchor" href="#_1-齐套分析算法-优先级抢占-kitting-logic" aria-label="Permalink to &quot;1. 齐套分析算法：优先级抢占 (Kitting Logic)&quot;">​</a></h2><h3 id="企业痛点" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“小客户的订单先开工，把大客户的急料给用了”</strong>。</p><h3 id="开发逻辑点" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>排序引擎</strong>: 开发者需实现一个基于 <code>Priority + Due_Date + Order_Amount</code> 的多因子排序算法。</li><li><strong>库存分配逻辑 (Allocation)</strong>: <ul><li>开发者需在内存中维护一个“虚拟库存池”。</li><li>循环订单列表，按 BOM 扣减虚拟库存。</li><li><strong>开发注意</strong>: 必须处理“半齐套”状态（如：缺 1 个零件，齐套率 99%）。</li></ul></li><li><strong>结果持久化</strong>: 将齐套分析结果存入 <code>Kitting_Result_Table</code>，供车间主管决定是否下达生产。</li></ul><h3 id="postgresql-实现建议" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>窗口函数预排序</strong>: 利用 <code>DENSE_RANK()</code> 或 <code>ROW_NUMBER()</code> 在数据库层完成复杂因子的初步排序，减轻应用层压力。</li><li><strong>CTE 递归齐套</strong>: 若存在多级子件，使用 <code>WITH RECURSIVE</code> 展开 BOM 并结合 <code>inventory</code> 表计算每一级的齐套情况。</li><li><strong>咨询锁 (Advisory Locks)</strong>: 在进行齐套分析期间，对特定物料或仓库使用 <code>pg_advisory_xact_lock(item_id)</code>，防止多个齐套任务同时抢占同一批库存。</li></ul><hr><h2 id="_2-领料模式的逻辑实现-issue-modes" tabindex="-1">2. 领料模式的逻辑实现 (Issue Modes) <a class="header-anchor" href="#_2-领料模式的逻辑实现-issue-modes" aria-label="Permalink to &quot;2. 领料模式的逻辑实现 (Issue Modes)&quot;">​</a></h2><h3 id="企业痛点-1" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-1" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p>“有些料是领一套发一套，有些料是直接放一筐在旁边自己拿”。</p><h3 id="开发逻辑点-1" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-1" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>推式领料 (Push - 配套发料)</strong>: <ul><li>开发者需根据 <code>MO_Component_List</code> 生成 <code>Pick_List</code>。</li><li><strong>校验逻辑</strong>: <code>发料量 &lt;= (标准用量 - 已领料量)</code>。严禁未审批的超领。</li></ul></li><li><strong>拉式领料 (Pull - 倒冲发料)</strong>: <ul><li>开发者不应在发料环节写逻辑。</li><li><strong>逻辑点</strong>: 在“完工汇报”事务完成后，异步触发一个 <code>Backflush_Job</code>，根据 BOM 用量自动扣减线边仓库存。</li><li><strong>异常处理</strong>: 如果线边仓库存不足，开发者需将该任务挂起并通知人工补料。</li></ul></li></ul><h3 id="postgresql-实现建议-1" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-1" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>LISTEN/NOTIFY 异步驱动</strong>: 完工申报后发出 <code>NOTIFY mo_complete_channel, &#39;MO_ID_123&#39;</code>，后台 Worker 进程 <code>LISTEN</code> 并触发倒冲逻辑，实现业务解耦。</li><li><strong>触发器强制约束</strong>: 在领料单明细表上设置 <code>CHECK</code> 约束或 <code>BEFORE INSERT</code> 触发器，确保 <code>issued_qty</code> 不超过 <code>required_qty</code>（除非有超领审批标记）。</li><li><strong>批量处理</strong>: 使用 <code>UNNEST</code> 函数一次性传入多个领料行，减少与数据库的交互往返次数。</li></ul><hr><h2 id="_3-线边仓与在制品-wip-inventory" tabindex="-1">3. 线边仓与在制品 (WIP Inventory) <a class="header-anchor" href="#_3-线边仓与在制品-wip-inventory" aria-label="Permalink to &quot;3. 线边仓与在制品 (WIP Inventory)&quot;">​</a></h2><h3 id="企业痛点-2" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-2" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“物料领走了，但在财务报表里消失了”</strong>。</p><h3 id="开发逻辑点-2" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-2" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>调拨事务</strong>: 领料不是“出库（销账）”，而是“调拨（仓库 A -&gt; 线边仓 B）”。</li><li><strong>资产权属</strong>: 开发者需确保在线边仓中，物料仍然带有 <code>ProjectID</code> 或 <code>MOID</code> 标识。</li><li><strong>盘点逻辑</strong>: 线边仓的盘点差异需自动计入“制造费用 - 物料损耗”。</li></ul><h3 id="postgresql-实现建议-2" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-2" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>复合索引优化</strong>: 在 <code>inventory_balance</code> 表上建立 <code>(warehouse_id, item_id, project_id, mo_id)</code> 的复合索引，加速线边仓精准查询。</li><li><strong>JSONB 扩展属性</strong>: 利用 <code>JSONB</code> 字段存储非核心的业务标识（如：工位号、班组），避免频繁修改表结构。</li><li><strong>存储过程封装</strong>: 将调拨逻辑（减少 A 库、增加 B 库、写入流水）封装在 <code>PL/pgSQL</code> 函数中，确保 ACID 特性。</li></ul><hr><h2 id="_4-超领控制与成本归集-over-issue-control" tabindex="-1">4. 超领控制与成本归集 (Over-issue Control) <a class="header-anchor" href="#_4-超领控制与成本归集-over-issue-control" aria-label="Permalink to &quot;4. 超领控制与成本归集 (Over-issue Control)&quot;">​</a></h2><h3 id="企业痛点-3" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-3" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p>“工人领多了料，没人知道这多出来的料去哪了”。</p><h3 id="开发逻辑点-3" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-3" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>审批工作流</strong>: 开发者需在 <code>Material_Issue</code> API 中增加拦截：<code>IF (Current_Qty &gt; Required_Qty) THEN 强制要求关联 Over_Issue_Form_ID</code>。</li><li><strong>成本标记</strong>: 超领的物料需被打上“异常损耗”标签，以便在 FI（财务）模块进行成本核算时，不计入标准产品价值，而是直接计入当期损益。</li></ul><h3 id="postgresql-实现建议-3" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-3" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>视图区分标准与异常</strong>: 创建 <code>v_mo_material_cost</code> 视图，使用 <code>CASE WHEN</code> 自动区分 <code>standard_cost</code> 和 <code>variance_cost</code>（超领部分）。</li><li><strong>部分索引 (Partial Index)</strong>:<div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INDEX</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> idx_over_issue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> material_issue (mo_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> is_over_issue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TRUE;</span></span></code></pre></div>方便财务快速检索所有超领记录进行月度分析。</li></ul><hr><h2 id="_5-开发者-checklist" tabindex="-1">5. 开发者 Checklist <a class="header-anchor" href="#_5-开发者-checklist" aria-label="Permalink to &quot;5. 开发者 Checklist&quot;">​</a></h2><ul><li>[ ] <strong>性能</strong>: 齐套分析涉及海量 BOM 展开和库存扫描，建议使用存储过程或分布式计算引擎。</li><li>[ ] <strong>事务一致性</strong>: 领料入库、库存扣减、MO 状态更新必须在一个事务中。</li><li>[ ] <strong>条码集成</strong>: 接口是否支持 PDA 扫描条码发料？（必须支持 <code>SN/Lot</code> 校验）。</li><li>[ ] <strong>回滚逻辑</strong>: 领料单作废时，是否能精准退回已预留的库存？</li></ul>',38)])])}const p=o(r,[["render",s]]);export{u as __pageData,p as default};
