# BOM 维护与多版本控制 (BOM) - 开发者详尽指南

## 概述
物料清单（BOM）是制造系统的“基因”。开发者必须意识到：BOM 不是一张静态的表，而是一个**具有时间维度的递归树结构**。一旦递归逻辑写错或没有处理好“环路检查”，整个 MRP 运算和成本卷积都会陷入死循环。

---

## 1. BOM 的物理存储与递归查询 (Data Structure)

### 企业痛点
一个成品可能有 5000 个零件，分 10 层。如果开发者用简单的 `JOIN` 去查全阶 BOM，性能会极慢。

### 开发逻辑点
- **存储模型**: 
    - `BOM_Header`: 记录父件、版本、状态。
    - `BOM_Component`: 记录子件、用量、位置、损耗、生效日期。
- **递归优化**: 
    - 开发者必须掌握 **CTE (Common Table Expressions)** 或使用 **路径枚举/闭包表** 来加速树状查询。
    - **低层码 (Low Level Code)**: 每一个料品必须存储其在全局所有 BOM 中的最大深度。开发者在 MRP 运算时必须按 `LLC` 升序排列，确保先算父件再算子件。
- **环路检查 (Circular Check)**: 在保存 BOM 时，开发者必须运行一个递归检测算法，防止出现 `A 包含 B, B 包含 C, C 包含 A` 的逻辑死循环。

---

## 2. 损耗率与有效用量的计算 (Usage Calculation)

### 企业痛点
**“算少了领不到料，算多了仓库积压”**。

### 核心公式
开发者在做领料计算时，必须实现以下精密逻辑：
- `单台标准用量 = 基础用量 / 基础基数`。
- `考虑损耗的用量 = 单台标准用量 * (1 + 变动损耗率) + 固定损耗`。
- `实际发料量 = 订单需求量 / 产出率`。

---

## 3. 虚设件 (Phantom) 的穿透处理

### 企业痛点
为了方便管理，工程师会定义一个“虚拟组合件”，它不入库、不贴标签。

### 开发逻辑点
- **穿透逻辑**: 在生产订单生成备料计划时，开发者需检测子件的 `SupplyType`。
- **逻辑**: 如果是 `Phantom`，则**跳过该件**，将其子件直接挂到当前的生产订单下。这是一个递归过程，直到遇到非虚设件为止。

---

## 4. 替代料与优先级逻辑 (Substitution)

### 企业痛点
“A 缺货了，可以用 B 顶替，但 B 也缺货时可以用 C”。

### 开发逻辑点
- **替代组模型**: 建立 `Substitution_Group`。
- **自动分配算法**: 开发者在运行 MRP 或库存预留时，需按 `Priority` 顺序扫描库存。
    - *开发注意*: 必须实现“部分替代”逻辑（如：需要 100 个，A 有 30 个，B 有 70 个）。

---

## 5. 版本切换与时间轴控制 (Effectivity)

### 企业痛点
“10 月 1 号开始用新零件，但 9 月 30 号还没到期的旧零件要先用完”。

### 开发逻辑点
- **日期过滤**: 所有的 BOM 查询接口必须带入 `EffectDate` 参数。
- **SQL 示例**: `WHERE component.start_date <= :targetDate AND (component.end_date IS NULL OR component.end_date > :targetDate)`。
- **软切换**: 开发者需支持“用完即换”逻辑，即 ECN 生效后，优先消耗旧料库存，库存清零后才切换到新料版本。

---

## 6. 开发者 Checklist

- [ ] **级联删除**: 严禁删除已发布的 BOM 记录，必须通过 ECN 进行版本迭代。
- [ ] **单位换算**: 子件单位与父件单位不一致时，是否调用了 `UOM_Convert` 函数？
- [ ] **物料状态校验**: BOM 中是否包含已停用的料品？（保存前需强校验）。
- [ ] **成本卷积触发**: BOM 变更后，是否标记了“成本需重算”标志位？
