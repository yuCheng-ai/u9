# 工序汇报与移动点管理 - 开发者详尽指南

## 概述
工序汇报（Reporting）是 ERP 系统的“神经网络”。开发者必须理解：汇报不只是填个数字，它是**物料流转、工序结转、成本分配、质量追溯**的联合触发器。如果汇报逻辑不严密，生产进度就会失真，成本核算就会变成“乱账”。

---

## 1. 工序流转的逻辑约束 (Operation Move Logic)

### 企业痛点
**“第一道工序还没做完，第二道工序就报工了，数据全乱了”**。

### 开发逻辑点
- **前置工序校验**: 
    - 开发者需在报工 API 中实现逻辑：`IF (Op20.Report_Qty > Op10.Passed_Qty) THEN REJECT_REPORT`。
    - **特例处理**: 支持“并行工序”或“搭接工序”的特殊校验逻辑。
- **移动点模型 (Move Point)**: 
    - 每一个工序汇报应产生两条记录：`汇报（报数）` 和 `移动（传给下一站）`。
    - 开发者需维护 `Operation_WIP_Balance` 表，实时记录每一道工序的“待加工”、“加工中”、“已完工待移走”状态。

### PostgreSQL 实现建议
- **行级并发控制**: 使用 `SELECT ... FOR UPDATE` 锁定特定工序的 `WIP_Balance` 记录，确保在高频报工环境下数量增减的绝对准确。
- **递归状态追溯**: 利用 `WITH RECURSIVE` 向上追溯所有前置工序的累计产出，确保当前工序报工数不超标。
- **状态快照 (JSONB)**: 在汇报记录中通过 `JSONB` 字段保存当时的工序状态快照，便于后期进行生产过程的“数字化回放”。

---

## 2. 产出数量的精细化处理 (Yield & Scrap)

### 企业痛点
“报废了 10 个，但系统里还是按 100 个在算成本”。

### 开发逻辑点
- **三量模型**: 开发者必须强制采集三个维度：
    - `Qualified_Qty` (合格): 计入下一道工序的可用数。
    - `Scrap_Qty` (报废): 触发原材料成本核销，不再向下流转。
    - `Rework_Qty` (返修): 挂起该部分数量，直到返修合格。
- **自动补料申请**: 
    - 如果 `报废量 > 预设损耗`，开发者需自动生成一条“补料申请建议”发给生产主管。

### PostgreSQL 实现建议
- **约束校验 (CHECK)**: 在数据库层增加约束，确保 `qualified_qty + scrap_qty + rework_qty <= input_qty`，防止应用层逻辑漏洞导致的数据溢出。
- **异步触发补料 (NOTIFY)**: 当报废量触发阈值时，通过 `NOTIFY` 发送消息，由后台服务异步处理补料逻辑，避免阻塞报工主流程。
- **物化视图汇总**: 使用物化视图汇总各车间的报废率，为管理层提供实时质量预警。

---

## 3. 工时采集与效率分析 (Time Tracking)

### 企业痛点
**“工人都说干了 8 小时，但产出只有 4 小时的量”**。

### 开发逻辑点
- **时间戳采集**: 
    - 开发者不应只提供“工时”录入框。
    - 更好的设计是 `StartTime` 和 `EndTime`。接口需校验：`EndTime - StartTime` 是否等于录入的 `WorkHours`。
- **效率计算公式**: 
    - `效率 = (合格产出 * 标准工时) / 实际投入工时`。
    - 开发者需实现一个异步计算引擎，每天凌晨汇总当天的“工序效率排行”。

### PostgreSQL 实现建议
- **时间范围类型 (TSRANGE)**: 使用 `tsrange` 存储工人的作业时间段，并利用 `EXCLUDE` 约束防止同一工人或机器在同一时间内重叠报工。
  ```sql
  ALTER TABLE labor_report ADD EXCLUDE USING gist (worker_id WITH =, work_period WITH &&);
  ```
- **窗口函数分析**: 
  ```sql
  SELECT worker_id, 
         SUM(UPPER(work_period) - LOWER(work_period)) OVER(PARTITION BY worker_id) as total_time
  FROM labor_report;
  ```
- **自动聚合 (pg_cron)**: 配置 `pg_cron` 定时任务，在低峰期自动执行效率分析聚合脚本。

---

## 4. 完工入库的自动触发 (Auto-Finish)

### 企业痛点
“最后一道工序报工了，但成品库里还没看见货”。

### 开发逻辑点
- **末道工序逻辑**: 
    - 开发者需在工序定义中增加 `Is_Final_Operation` 标志位。
- **自动入库**: 当末道工序汇报审核时，开发者需自动调用 `Inventory_In_API` 生成“成品入库单”。
- **事务保证**: 汇报与入库必须在同一个数据库事务中，防止数据不一致。

### PostgreSQL 实现建议
- **存储过程封装**: 将“末道报工 + 库存增加 + 状态更新”封装在一个 `PL/pgSQL` 函数中，确保事务的原子性。
- **外键级联检查**: 通过外键关联确保入库单必须引用有效的报工单记录。
- **审计日志**: 利用 PG 的 `INSERT INTO ... RETURNING` 语法，在完成自动入库后立即获取入库单号并反馈给前端。

---

## 5. 开发者 Checklist

- [ ] **幂等性**: 工人可能因为网络问题点击两次“汇报”，接口必须支持幂等（通过唯一 `RequestID` 校验）。
- [ ] **PDA 适配**: 汇报接口是否支持高频、简化的扫描调用？
- [ ] **人员校验**: 报工人员是否属于该 `WorkCenter`？
- [ ] **逆向操作**: 报工撤销（Un-report）时，是否能级联撤销后续已生成的入库单和成本凭证？
