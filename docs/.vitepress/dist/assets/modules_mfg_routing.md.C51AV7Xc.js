import{_ as s,c as n,o as e,ae as i}from"./chunks/framework.CDjunVez.js";const u=JSON.parse('{"title":"工艺路线与资源 (Routing) - 开发者详尽指南","description":"","frontmatter":{},"headers":[],"relativePath":"modules/mfg/routing.md","filePath":"modules/mfg/routing.md"}'),t={name:"modules/mfg/routing.md"};function o(l,a,r,p,c,d){return e(),n("div",null,[...a[0]||(a[0]=[i(`<h1 id="工艺路线与资源-routing-开发者详尽指南" tabindex="-1">工艺路线与资源 (Routing) - 开发者详尽指南 <a class="header-anchor" href="#工艺路线与资源-routing-开发者详尽指南" aria-label="Permalink to &quot;工艺路线与资源 (Routing) - 开发者详尽指南&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>如果说 BOM 是“配方”，那么工艺路线（Routing）就是“烹饪步骤”。开发者必须理解：工艺路线是<strong>工序、工时、工作中心、设备资源</strong>的四维坐标系。它是生产排产（APS）和工序成本（Costing）的底层骨架。</p><hr><h2 id="_1-工序与时间模型-operation-time-model" tabindex="-1">1. 工序与时间模型 (Operation &amp; Time Model) <a class="header-anchor" href="#_1-工序与时间模型-operation-time-model" aria-label="Permalink to &quot;1. 工序与时间模型 (Operation &amp; Time Model)&quot;">​</a></h2><h3 id="企业痛点" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“算出来的生产工期永远不准，不是早了就是晚了”</strong>。</p><h3 id="开发逻辑点" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>精密工时模型</strong>: 开发者需支持以下四种时间维度的累加： <ul><li><code>Setup_Time</code> (准备时间): 与批量无关（如：洗锅、调机）。</li><li><code>Run_Time</code> (运行时间): 与批量正相关（如：炒菜）。</li><li><code>Wait_Time</code> (等待时间): 工序内必须的物理等待（如：冷却、发酵）。</li><li><code>Move_Time</code> (移动时间): 工序间的转运时间。</li></ul></li><li><strong>排程公式</strong>: <code>Total_Operation_Time = Setup_Time + (Run_Time * Order_Qty) + Wait_Time + Move_Time</code>。</li><li><strong>开发注意</strong>: 所有的工时必须支持“秒/分/时”的单位转换，且精度至少保留 4 位小数。</li></ul><h3 id="postgresql-实现建议" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>数值类型精度 (NUMERIC)</strong>: 使用 <code>NUMERIC(20, 4)</code> 存储工时，确保在进行单位换算（如：秒转时）时不会出现浮点数精度丢失。</li><li><strong>时间跨度计算 (INTERVAL)</strong>: 利用 PG 的 <code>INTERVAL</code> 类型处理工序间的等待和移动时间，方便进行日期加减运算：<code>plan_finish_date = plan_start_date + (total_time * interval &#39;1 second&#39;)</code>。</li><li><strong>自定义函数封装</strong>: 编写 <code>PL/pgSQL</code> 函数统一计算总工时，方便在视图和触发器中复用排程公式。</li></ul><hr><h2 id="_2-工作中心与共享资源冲突-work-center-shared-resources" tabindex="-1">2. 工作中心与共享资源冲突 (Work Center &amp; Shared Resources) <a class="header-anchor" href="#_2-工作中心与共享资源冲突-work-center-shared-resources" aria-label="Permalink to &quot;2. 工作中心与共享资源冲突 (Work Center &amp; Shared Resources)&quot;">​</a></h2><h3 id="企业痛点-1" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-1" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><ul><li><strong>能力建模 (Capacity)</strong>: “明明只有 3 台机器，系统却排了 5 个人的活”。</li><li><strong>共享资源冲突</strong>: 当多个工作中心共用同一台关键设备（如大型烘箱）时，排程算法如何处理资源抢占？</li></ul><h3 id="开发逻辑点-1" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-1" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>资源抽象</strong>: 设备应作为独立资源（Resource）被多个工作中心引用。</li><li><strong>有限能力校验 (Finite Capacity)</strong>: <ul><li>在排产接口中，开发者需增加“超载拦截”逻辑。</li><li><strong>排程算法</strong>: <code>Next_Available_Start_Date = MAX(Resource_Busy_Until, Material_Ready_Date)</code>。</li></ul></li></ul><h3 id="postgresql-实现建议-1" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-1" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>GIST 索引与排除约束 (Exclusion Constraints)</strong>:<div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 强制设备资源在时间轴上不重叠</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resource_allocation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EXCLUDE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">USING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gist (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  resource_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  busy_period </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><strong>咨询锁 (Advisory Locks)</strong>: 在进行高频排产模拟时，利用 <code>pg_try_advisory_lock</code> 快速锁定资源，防止并发排程冲突。</li></ul><hr><h2 id="_3-委外工序的逻辑穿透-subcontracting-operation" tabindex="-1">3. 委外工序的逻辑穿透 (Subcontracting Operation) <a class="header-anchor" href="#_3-委外工序的逻辑穿透-subcontracting-operation" aria-label="Permalink to &quot;3. 委外工序的逻辑穿透 (Subcontracting Operation)&quot;">​</a></h2><h3 id="企业痛点-2" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-2" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“中间有一道电镀工序是外协的，系统里就断档了，根本不知道货在哪”</strong>。</p><h3 id="开发逻辑点-2" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-2" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>逻辑跳变</strong>: <ul><li>当工序属性 <code>Is_Subcontracted == True</code> 时，开发者需触发“采购逻辑”。</li><li><strong>自动触发</strong>: 生产订单下达到该工序时，自动生成 <code>Subcontract_Purchase_Request</code>。</li></ul></li><li><strong>物流跟踪</strong>: <ul><li>开发者需设计 <code>Operation_Transfer_Out</code>（发出给委外商）和 <code>Operation_Transfer_In</code>（从委外商收回）事务，确保 WIP 价值链不断裂。</li></ul></li></ul><h3 id="postgresql-实现建议-2" tabindex="-1">PostgreSQL 实现建议 <a class="header-anchor" href="#postgresql-实现建议-2" aria-label="Permalink to &quot;PostgreSQL 实现建议&quot;">​</a></h3><ul><li><strong>触发器联动</strong>: 在工序流转表上设置 <code>AFTER UPDATE</code> 触发器，当委外工序状态变为“待发出”时，自动向 <code>purchase_request</code> 表插入记录。</li><li><strong>JSONB 记录物流轨迹</strong>:<div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></li></ul><p>{ &quot;subcontractor&quot;: &quot;Vendor_A&quot;, &quot;shipped_at&quot;: &quot;2023-10-01&quot;, &quot;expected_back&quot;: &quot;2023-10-05&quot;, &quot;tracking_no&quot;: &quot;SF123456&quot; }</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  利用 \`JSONB\` 存储动态的外协物流信息，无需为每种外协业务修改表结构。</span></span>
<span class="line"><span>- **外部数据源 (postgres_fdw)**: 如果委外商使用了独立的协作系统，可以通过 \`postgres_fdw\` 直接在 ERP 中查询外协进度。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>---</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 4. 关键工序与移动控制 (Move Control)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### 企业痛点</span></span>
<span class="line"><span>“前面的工序还没干完，后面的就报工了，导致报表上的在制品数量是负数”。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### 开发逻辑点</span></span>
<span class="line"><span>- **移动策略 (Move Policy)**: </span></span>
<span class="line"><span>    - 开发者需在工序定义中增加 \`Move_Point_Flag\`。</span></span>
<span class="line"><span>    - **逻辑**: 只有在 \`Qualified_Qty\` 产生后，才允许调用 \`Operation_Move_API\`。</span></span>
<span class="line"><span>- **关键路径 (Critical Path)**: </span></span>
<span class="line"><span>    - 开发者需支持“里程碑汇报”。只有关键工序汇报了，才更新 MO 的整体百分比进度。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### PostgreSQL 实现建议</span></span>
<span class="line"><span>- **递归 CTE 路径检查**: </span></span>
<span class="line"><span>  \`\`\`sql</span></span>
<span class="line"><span>  WITH RECURSIVE op_path AS (</span></span>
<span class="line"><span>    SELECT id, next_op_id, is_completed FROM routing WHERE mo_id = ? AND op_seq = 1</span></span>
<span class="line"><span>    UNION ALL</span></span>
<span class="line"><span>    SELECT r.id, r.next_op_id, r.is_completed FROM routing r JOIN op_path p ON r.id = p.next_op_id</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>  SELECT bool_and(is_completed) FROM op_path WHERE id &lt; current_op_id;</span></span></code></pre></div><p>使用递归查询确保当前工序之前的所有必要步骤均已完成。</p><ul><li><strong>触发器维护进度</strong>: 在汇报表上设置触发器，实时累加关键工序产出，并更新 MO 主表的 <code>completion_percentage</code> 字段。</li><li><strong>布尔索引</strong>: 对 <code>is_critical_path</code> 字段建立索引，加速进度看板的查询性能。</li></ul><hr><h2 id="_5-开发者-checklist" tabindex="-1">5. 开发者 Checklist <a class="header-anchor" href="#_5-开发者-checklist" aria-label="Permalink to &quot;5. 开发者 Checklist&quot;">​</a></h2><ul><li>[ ] <strong>递归路径</strong>: 复杂的工艺路线可能包含分支（并行工序），排程算法是否支持“同步开始”或“同步结束”？</li><li>[ ] <strong>成本中心关联</strong>: 每一个工作中心是否都正确映射到了财务的 <code>Cost_Center</code>？</li><li>[ ] <strong>版本切换</strong>: 正在生产的订单是否支持“在线切换”工艺路线？（涉及 WIP 重算）。</li><li>[ ] <strong>效率系数</strong>: 开发者是否预留了“设备稼动率”和“人员熟练度”对工时的修正系数接口？</li></ul>`,34)])])}const g=s(t,[["render",o]]);export{u as __pageData,g as default};
