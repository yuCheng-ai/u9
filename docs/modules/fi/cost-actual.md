# 实际成本核算 (Actual Costing) - 开发者详尽指南

## 概述
实际成本（Actual Costing）是 ERP 中逻辑最复杂、计算量最大的模块。它不是简单的“加减法”，而是对企业**价值流**的全面还原。对于开发者来说，这不仅是写 SQL，而是要通过代码实现一个**多级卷积运算引擎**。

---

## 1. 成本域与成本中心 (Cost Domain & Center)

### 企业痛点
有些工厂很大，但财务只想按车间核算成本；有些企业有多个工厂，但想共用一套料品单价。如果开发者把成本逻辑写死在“组织”层级，就无法应对这种灵活的核算口径。

### 开发逻辑点
- **成本域 (Cost Domain)**: 这是核算的边界。开发者在做单价计算时，必须按 `CostDomainID + ItemID` 进行 Group By，而非 `OrgID`。
- **成本中心 (Cost Center)**: 费用归集的容器。每一个制造费用凭证必须关联 `CostCenterID`。

### PostgreSQL 实现建议
- **复合索引优化**: 在 `inventory_transaction` 表上对 `(cost_domain_id, item_id, transaction_date)` 建立复合索引，极大地提升月度加权平均单价的计算速度。
- **行级安全 (RLS)**: 对不同成本域的数据应用 RLS，确保财务人员只能在其权限范围内的成本域执行核算操作，防止跨域数据污染。

---

## 2. 费用归集与分摊引擎 (Allocation Engine)

### 企业痛点
**“这月 100 万电费，怎么摊到 1000 种产品上？”**。如果开发者只给一个固定的分摊逻辑，财务每天都要手工拉 Excel。

### 开发逻辑点
- **分摊动因 (Drivers)**: 开发者需支持多种动因：
    - **工时占比**: `该产品总工时 / 全厂总工时`。
    - **产量占比**: `该产品入库数量 / 全厂总产量`。
    - **产值占比**: `该产品标准金额 / 全厂标准金额`。
- **分摊路径**: 
    - 辅助生产部门（如动力车间） -> 生产车间 -> 生产订单。
    - **开发注意**: 必须实现“交互分配法”，处理部门之间的相互服务（循环分摊），通常需要迭代计算或解线性方程组。

### PostgreSQL 实现建议
- **窗口函数计算占比**: 
  ```sql
  SELECT mo_id, 
         labor_hours, 
         labor_hours / SUM(labor_hours) OVER(PARTITION BY cost_center_id) as ratio
  FROM mo_reporting;
  ```
  利用窗口函数直接在 SQL 层完成分摊比例计算，避免在应用层进行两次汇总查询。
- **物化视图预汇总**: 将常用的分摊动因（如各订单累计工时、各产品月度产量）预先汇总到物化视图中，提升分摊引擎的执行效率。

---

## 3. 多级卷积计算 (Multi-level Rollup)

### 企业痛点
**“半成品的成本算错了，成品的成本就全错了”**。制造企业通常有 10 层以上的 BOM。

### 核心算法
- **低层码 (Low Level Code)**: 开发者必须先计算物料在所有 BOM 中的最低层级。
- **计算顺序**: 必须按照低层码从大到小（从最底层的原材料到最顶层的成品）进行卷积。
- **卷积逻辑**:
    - `本级成本 = 直接材料 (由下级传递) + 直接人工 (本级报工) + 制造费用 (分摊所得)`。

### PostgreSQL 实现建议
- **递归 CTE 计算低层码**: 
  ```sql
  WITH RECURSIVE bom_levels AS (
    SELECT child_id, 1 as level FROM bom_struct WHERE parent_id IS NULL
    UNION ALL
    SELECT b.child_id, bl.level + 1 FROM bom_struct b JOIN bom_levels bl ON b.parent_id = bl.child_id
  )
  SELECT child_id, MAX(level) as low_level_code FROM bom_levels GROUP BY child_id;
  ```
  使用递归 CTE 高效生成全量物料的低层码，这是成本卷积的基础。
- **临时表缓存中间结果**: 在 `PL/pgSQL` 中使用 `LOCAL TEMPORARY TABLE` 存储每一层级的计算结果，减少对物理表的频繁 I/O。

---

## 4. 在制品 (WIP) 与完工结算

### 企业痛点
月末了，生产线上还有一半没做完的货。这部分钱算在“库存”里还是“费用”里？

### 开发逻辑点
- **约当产量法**: 开发者需根据工序的“完工程度”（如 50%），将 WIP 折算为成品数量参与分摊。
- **尾差处理**: 在最后一步结算时，必须实现 `总成本 - 已完工成本 = 留存 WIP 成本`，防止因为四舍五入导致总账不平。

### PostgreSQL 实现建议
- **精确数值运算 (NUMERIC)**: 全程使用 `NUMERIC(28, 10)` 进行成本计算，仅在最后生成财务凭证时进行舍入，最大限度减少计算尾差。
- **触发器实时监控**: 在成本结算表上设置触发器，实时校验 `input = output` 的平衡关系，一旦失衡立即阻断操作并报警。
- **JSONB 记录分摊轨迹**: 将每一笔成本的构成明细（料、工、费）以 `JSONB` 格式记录在结算行中，实现“一键追溯”成本来源。

---

## 5. 开发者 Checklist

- [ ] **性能优化**: 成本卷积涉及海量递归。开发者必须使用临时表（Temp Table）或内存计算，严禁在循环中查询数据库。
- [ ] **异常监控**: 必须捕获“无单价原材料”、“零工时产成品”等异常情况，并输出完整的 `ErrorLog`，而非让计算崩溃。
- [ ] **数据快照**: 在开始核算前，必须对当前的收发货记录进行“快照锁定”，防止核算过程中业务员修改单据。
- [ ] **可追溯性**: 每一笔分摊出的费用，必须保留 `SourceVoucherID`，支持财务人员从结果反查到原始电费单。
