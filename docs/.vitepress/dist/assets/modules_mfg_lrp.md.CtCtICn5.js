import{_ as o,c as t,o as a,ae as l}from"./chunks/framework.CDjunVez.js";const u=JSON.parse('{"title":"LRP 批次需求计划 (LRP) - 开发者详尽指南","description":"","frontmatter":{},"headers":[],"relativePath":"modules/mfg/lrp.md","filePath":"modules/mfg/lrp.md"}'),e={name:"modules/mfg/lrp.md"};function n(i,r,s,g,d,h){return a(),t("div",null,[...r[0]||(r[0]=[l('<h1 id="lrp-批次需求计划-lrp-开发者详尽指南" tabindex="-1">LRP 批次需求计划 (LRP) - 开发者详尽指南 <a class="header-anchor" href="#lrp-批次需求计划-lrp-开发者详尽指南" aria-label="Permalink to &quot;LRP 批次需求计划 (LRP) - 开发者详尽指南&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>LRP（Lot Requirements Planning）是 U9 的“杀手锏”。对于开发者来说，MRP 是“全局网状计算”，而 LRP 是**“线性链条计算”<strong>。它的核心任务是建立并维护一条从销售订单到采购单的</strong>硬连接（Hard Pegging）**。</p><hr><h2 id="_1-供需链条的-硬锁定-逻辑-hard-pegging" tabindex="-1">1. 供需链条的“硬锁定”逻辑 (Hard Pegging) <a class="header-anchor" href="#_1-供需链条的-硬锁定-逻辑-hard-pegging" aria-label="Permalink to &quot;1. 供需链条的“硬锁定”逻辑 (Hard Pegging)&quot;">​</a></h2><h3 id="企业痛点" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“明明是给 A 客户买的料，被 B 客户的订单领走了”</strong>。</p><h3 id="开发逻辑点" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>需求标识 (DemandID)</strong>: 每一个 LRP 产生的建议单据都必须存储源单标识。 <ul><li><strong>PG 实现建议</strong>: 利用 PostgreSQL 的 <strong><code>UUID</code></strong> 作为全局唯一的需求追踪 ID，并在所有关联表上建立索引。</li></ul></li><li><strong>库存隔离</strong>: <ul><li>开发者需在库存表设计 <code>ProjectID</code> 字段。</li><li><strong>PG 实现建议</strong>: 启用 <strong>行级安全 (RLS)</strong>，让生产领料单只能“看见”属于其项目或 LRP 批次的库存，在数据库层级实现强硬锁定。</li></ul></li><li><strong>自动锁定</strong>: <ul><li>入库时自动过账到逻辑私有仓。</li><li><strong>PG 实现建议</strong>: 使用 <strong>触发器 (Triggers)</strong> 在库存更新时自动填充 <code>LRP_Batch_ID</code>。</li></ul></li></ul><hr><h2 id="_2-齐套分析算法-kitting-analysis" tabindex="-1">2. 齐套分析算法 (Kitting Analysis) <a class="header-anchor" href="#_2-齐套分析算法-kitting-analysis" aria-label="Permalink to &quot;2. 齐套分析算法 (Kitting Analysis)&quot;">​</a></h2><h3 id="企业痛点-1" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-1" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p><strong>“生产线开工了才发现少一个零件，全线停工”</strong>。</p><h3 id="开发逻辑点-1" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-1" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>模拟展开</strong>: 递归展开 BOM。 <ul><li><strong>PG 实现建议</strong>: 利用 PostgreSQL 的 <strong>递归 CTE (Recursive CTE)</strong> 实现毫秒级的全阶 BOM 需求展开。</li></ul></li><li><strong>匹配逻辑</strong>: <ul><li>专用库存 -&gt; 专用在途 -&gt; 缺口。</li><li><strong>PG 实现建议</strong>: 使用 <strong>窗口函数 (Window Functions)</strong> 和 <strong><code>FILTER</code> 子句</strong> 在单次扫描中完成“专用”与“通用”库存的优先级匹配计算。</li></ul></li><li><strong>计算最早开工日</strong>: <ul><li><code>MAX(到货日)</code>。</li><li><strong>PG 实现建议</strong>: 使用 <strong>自定义聚合函数</strong> 或 <strong>存储过程</strong> 封装齐套性检查算法，减少前后端数据交互开销。</li></ul></li></ul><hr><h2 id="_3-lrp-的局部计算引擎-local-engine" tabindex="-1">3. LRP 的局部计算引擎 (Local Engine) <a class="header-anchor" href="#_3-lrp-的局部计算引擎-local-engine" aria-label="Permalink to &quot;3. LRP 的局部计算引擎 (Local Engine)&quot;">​</a></h2><h3 id="企业痛点-2" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-2" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p>“运行一次全局 MRP 要 2 小时，我只想算这一个急单”。</p><h3 id="开发逻辑点-2" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-2" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>计算范围控制</strong>: <ul><li>以 <code>SourceOrderID</code> 为根节点。</li><li><strong>PG 实现建议</strong>: 使用 <strong><code>UNLOGGED TABLE</code></strong> 存储 LRP 计算过程中的中间数据，大幅提升写入性能，计算完成后自动清理。</li></ul></li><li><strong>并发冲突</strong>: <ul><li>全局排队或快照预留。</li><li><strong>PG 实现建议</strong>: 利用 PostgreSQL 的 <strong>咨询锁 (Advisory Locks)</strong> 实现对特定 LRP 任务的串行化控制，防止多个局部计算抢占同一批通用物料。</li></ul></li></ul><hr><h2 id="_4-批次合并与拆分逻辑-aggregation-split" tabindex="-1">4. 批次合并与拆分逻辑 (Aggregation &amp; Split) <a class="header-anchor" href="#_4-批次合并与拆分逻辑-aggregation-split" aria-label="Permalink to &quot;4. 批次合并与拆分逻辑 (Aggregation &amp; Split)&quot;">​</a></h2><h3 id="企业痛点-3" tabindex="-1">企业痛点 <a class="header-anchor" href="#企业痛点-3" aria-label="Permalink to &quot;企业痛点&quot;">​</a></h3><p>“虽然是按单采购，但螺丝钉总不能一颗一颗买，供应商不卖”。</p><h3 id="开发逻辑点-3" tabindex="-1">开发逻辑点 <a class="header-anchor" href="#开发逻辑点-3" aria-label="Permalink to &quot;开发逻辑点&quot;">​</a></h3><ul><li><strong>合并规则</strong>: <ul><li><strong>PG 实现建议</strong>: 利用 <strong><code>GROUP BY</code></strong> 结合 <strong><code>STRING_AGG</code></strong> 记录合并后的采购单关联的所有原始需求 ID，保持链路透明。</li></ul></li><li><strong>拆分溯源</strong>: <ul><li><strong>PG 实现建议</strong>: 利用 PostgreSQL 的 <strong>JSONB</strong> 存储合并明细，方便在到货入库时通过 SQL 函数快速拆分并更新各原始需求的满足状态。</li></ul></li></ul><hr><h2 id="_5-开发者-checklist" tabindex="-1">5. 开发者 Checklist <a class="header-anchor" href="#_5-开发者-checklist" aria-label="Permalink to &quot;5. 开发者 Checklist&quot;">​</a></h2><ul><li>[ ] <strong>高精度计算</strong>: 齐套分析涉及的各级数量换算是否统一使用 <strong><code>numeric</code></strong>？</li><li>[ ] <strong>数据完整性</strong>: 删除了源单后，是否通过 <strong>触发器</strong> 或 <strong>逻辑复制</strong> 级联更新了 LRP 链路状态？</li><li>[ ] <strong>跨组织协作</strong>: 是否利用 <strong><code>postgres_fdw</code></strong> 实现跨组织库存和需求的实时可见与锁定？</li><li>[ ] <strong>性能优化</strong>: 是否对 <code>DemandID</code> 和 <code>LRP_Batch_ID</code> 建立了高效的 B-Tree 索引？</li></ul>',30)])])}const P=o(e,[["render",n]]);export{u as __pageData,P as default};
